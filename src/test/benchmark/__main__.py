"""
Script to run a benchmark.
We generate variable signals and run the Optimizer
measuring the time it takes to solve for each signal.

From root, run with:
'python -m src.test'
"""

import os
import sys
import json
import random
import argparse
import subprocess
import numpy as np
import pandas as pd
import soundfile as sf
from pathlib import Path
from ...application import ReverbOptimizer

SR = 44_100
BIT_DEPTH = 16
PERIOD = 1.0 / SR
LOWER = -(2**BIT_DEPTH) / 2
UPPER = ((2**BIT_DEPTH) / 2) - 1
VERSION = 1

"""
A sine wave is represented by: y(t) = A*sin(w*t + phi)
- A: amplitude
- phi: phase
- w: 2*pi/T = 2*pi*f
- T: period 
"""
def signal_generator(
        name: str,
        freq: int, 
        complex: bool = True,
        length: int = 1,
        phase: int = 0) -> np.ndarray:
    """
    Depending on the length, we iteratively add 1s of a sine to the given signal
    of varying amplitude generated by random in a range of all possible amplitude values
    in a 16 Bit system.
    
    Parameters:
    -----------
        - y: given signal
        - freq: frequency of the sine to be constructed
        - length: array length in seconds (default is 1)
        - amp: sine amplitude
        - phase: phase of sine

    Returns:
    --------
        - y: signal
    """
    global VERSION

    # setup deterministic seed for reproducability
    random.seed(42)

    # define output directory for singal
    data_dir = Path("data") / "benchmark"
    os.mkdir.

    n_samples = length * SR
    t = np.arange(n_samples) * PERIOD

    if (complex):
        # determine number of transition
        n_anchors = random.randrange(0, min(SR / 100, 20))

        # define the anchor values
        # by setting the amplitude values randomly
        # by setting the positions randomly
        anchor_values = [random.randrange(LOWER, UPPER) for _ in range(0, n_anchors)]
        anchor_positions = sorted([0] + 
                            [random.randrange(0,n_samples) for _ in range(0, n_anchors-2 )] + 
                            [n_samples - 1])

        # now generate sin wave that interpolates between the anchor points
        shape = np.interp(np.arange(n_samples), anchor_positions, anchor_values)

        y = shape * np.sin(2 * np.pi * freq * t + phase)

        signal = np.vstack((y,y)).T
        
    
    else:
        # otherwise just generate a signal with varying amplitude values every second (from python numerical methods book)
        t = np.arange(0,1,PERIOD, dtype=np.float32)
        amp = random.randrange(LOWER,UPPER,1)
        signal = amp * np.sin(2 * np.pi * freq * t + phase)

        for _ in range(0, length):
            amp = random.randrange(LOWER,UPPER,1)
            signal += amp * np.sin(2 * np.pi * freq * t + phase)
    
    output = os.path.join(data_dir, name)
    print(output)
    #f = sf.SoundFile(output, 'w', SR, 2)
    #print(f"FuCKING WRITE {signal} and {f}")
    #f.write(data=signal)
    sf.write(file=output, data=signal, samplerate=SR, format='WAV', subtype="FLOAT")

    VERSION += 1

    return y


# define command-line options to specify
# num-runs
# max-signal-duration
# highest fequency (maximum is 20 kHz, since our system is bound to 44_100 SR)
parser = argparse.ArgumentParser(
    usage="\n \
        --num-runs has to specify the number of runs for our benchmark \n \
        --max-freq is the highest frequency our program should be tested with \n \
        as of now, the benchmark runs max_freq-20/1000 * max_duration // n_runs times \n \
        it will be changes to run only the specified number of times",
    description="This is a benchmark program to test our RevO application",
    epilog="Good good kid"
)

parser.add_argument('--num_runs', type=int, required=True, help="Number of benchmark runs per frequency", action="store")
parser.add_argument('--max_duration', type=int, required=True, help='Maximal duration of generated test signal in seconds', action="store")
parser.add_argument('--max_freq', type=int, required=True, help="Maximum frequency the test signal will be generated with", action="store")

args = parser.parse_args(args=sys.argv)
benchmark_dir = Path("benchmark_results")
benchmark_dir.mkdir(exist_ok=True)

# parse options into correct variables
n_runs = args.num_runs
max_freq = args.max_freq
max_duration = args.max_duration

results = []
# start benchmarking
# for frequencies in steps of 1000 Hz
for freqs in range(20, max_freq + 20, 1000):
    # for the specified number of times stretched over the time interval
    duration = 1
    run = 1
    jumps = max_duration // n_runs
    while (duration < max_duration):
        
        file_name = f"test_{freqs}Hz_{duration}s.wav"

        # now generate signal
        signal = signal_generator(
            name=file_name,
            freq=freqs, 
            complex=True, 
            length=duration)
        

        try:
            # run the optimizer with the generated signal
            # as a subprocess to ensure state consistency
            subprocess.run(["python", "m", "src.application",f"--audio-file {file_name}"])
            with open('stats.json', 'r') as f:
                stats = json.load(f)

            run_stats = {
                    'frequency': freqs,
                    'length': duration,
                    'run': run,
                    'choices': stats['choices'],
                    'conflicts': stats['conflicts'],
                    'constraints': stats['constraints'],
                    'solving_time': stats['time']['solve'],
                    'rules': stats['rules']
                }
                
            results.append(run_stats)
            df = pd.DataFrame(results)
            df.to_csv(benchmark_dir / f"benchmark_results_v{VERSION}.csv", index=False)


        except Exception as e:
            print(f"Error processing {file_name}: {e}")

        run += 1
        duration += jumps

working_dir = os.
results_file = Path("benchmark_results") / f"benchmark_results_v{VERSION}.csv"
df = pd.read_csv(results_file)