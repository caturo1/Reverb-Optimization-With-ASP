"""
Script to run a benchmark.
We generate variable signals and run the Optimizer
measuring the time it takes to solve for each signal.

From root, run with:
'python -m src.test'
"""

import os
import sys
import json
import random
import argparse
import subprocess
import numpy as np
import pandas as pd
import soundfile as sf
from pathlib import Path

SR = 44_100
BIT_DEPTH = 16
PERIOD = 1.0 / SR
LOWER = -(2**BIT_DEPTH) / 2
UPPER = ((2**BIT_DEPTH) / 2) - 1
VERSION = 1
PI = np.pi
MAX_PHASE_OFFSET = PI/2
DIR = "../../../benchmark_results/signals"

"""
A sine wave is represented by: y(t) = A*sin(w*t + phi)
- A: amplitude
- phi: phase
- w: 2*pi/T = 2*pi*f
- T: period 
"""
def signal_generator(
        name: str,
        freq: int, 
        length: int = 1,
        complex: bool = True,
        phase_offset: int = 0) -> np.ndarray:
    """
    Depending on the length, we iteratively add 1s of a sine to the given signal
    of varying amplitude generated by random in a range of all possible amplitude values
    in a 16 Bit system.
    
    Parameters:
    -----------
        - y: given signal
        - freq: frequency of the sine to be constructed
        - length: array length in seconds (default is 1)
        - amp: sine amplitude
        - phase: phase of sine

    Returns:
    --------
        - y: signal

    Also include: Different waveforms and varying frequencies and stereo
    
    """
    global VERSION

    # setup deterministic seed for reproducability
    random.seed(42)

    # no need to initialize the directory, because the bash script takes care of it
    # define output directory for singal
    #data_dir = Path("data") / "benchmark"
    #if not os.path.exists(data_dir):
    #    os.mkdir(data_dir)

    n_samples = length * SR
    t = np.arange(n_samples) * PERIOD

    if (complex):
        # determine number of transition
        n_anchors = random.randrange(0, min(SR / 100, 20))
        if phase_offset > MAX_PHASE_OFFSET or phase_offset < -MAX_PHASE_OFFSET:
            phase_offset = MAX_PHASE_OFFSET
        # define the anchor values 
        # by setting the amplitude values randomly
        # by setting the positions randomly
        anchor_values = [random.randrange(LOWER, UPPER) for _ in range(0, n_anchors)]
        anchor_positions = sorted([0] + 
                            [random.randrange(0,n_samples) for _ in range(0, n_anchors-2 )] + 
                            [n_samples - 1])

        # now generate sin wave that interpolates between the anchor points
        shape = np.interp(np.arange(n_samples), anchor_positions, anchor_values)

        y0 = shape * np.sin(2 * np.pi * freq * t)
        y1 = shape * np.sin(2 * np.pi * freq * t + phase_offset)

        # obviously that's not stereo, have to change that
        # maybe manipulate phase offset
        # or different amp values for both channels
        signal = np.vstack((y0,y1)).T
        
    
    else:
        # otherwise just generate a signal with varying amplitude values every second (from python numerical methods book)
        t = np.arange(0,1,PERIOD, dtype=np.float32)
        amp = random.randrange(LOWER,UPPER,1)
        signal = amp * np.sin(2 * np.pi * freq * t + phase_offset)

        for _ in range(0, length):
            amp = random.randrange(LOWER,UPPER,1)
            signal += amp * np.sin(2 * np.pi * freq * t + phase_offset)
    
    output = os.path.join(DIR, name)
    #print(output)
    #f = sf.SoundFile(output, 'w', SR, 2)
    #print(f"FuCKING WRITE {signal} and {f}")
    #f.write(data=signal)
    sf.write(file=output, data=signal, samplerate=SR, format='WAV', subtype="FLOAT")

    VERSION += 1

def main(args=sys.argv):
    signal_generator(freq=args[1], length=args[2], phase_offset=args[4], name=args[5])
